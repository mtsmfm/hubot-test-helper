// Generated by CoffeeScript 1.10.0
(function() {
  var Fs, Helper, Hubot, MockResponse, MockRobot, Path, Room,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Fs = require('fs');

  Path = require('path');

  Hubot = require('hubot');

  process.setMaxListeners(0);

  MockResponse = (function(superClass) {
    extend(MockResponse, superClass);

    function MockResponse() {
      return MockResponse.__super__.constructor.apply(this, arguments);
    }

    MockResponse.prototype.sendPrivate = function() {
      var ref, strings;
      strings = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.robot.adapter).sendPrivate.apply(ref, [this.envelope].concat(slice.call(strings)));
    };

    return MockResponse;

  })(Hubot.Response);

  MockRobot = (function(superClass) {
    extend(MockRobot, superClass);

    function MockRobot(httpd) {
      if (httpd == null) {
        httpd = true;
      }
      MockRobot.__super__.constructor.call(this, null, null, httpd, 'hubot');
      this.Response = MockResponse;
    }

    MockRobot.prototype.loadAdapter = function() {
      return this.adapter = new Room(this);
    };

    return MockRobot;

  })(Hubot.Robot);

  Room = (function(superClass) {
    extend(Room, superClass);

    function Room(robot1) {
      this.robot = robot1;
      this.messages = [];
      this.privateMessages = {};
      this.user = {
        say: (function(_this) {
          return function(userName, message) {
            return _this.receive(userName, message);
          };
        })(this),
        enter: (function(_this) {
          return function(userName) {
            return _this.enter(userName);
          };
        })(this),
        leave: (function(_this) {
          return function(userName) {
            return _this.leave(userName);
          };
        })(this)
      };
    }

    Room.prototype.receive = function(userName, message) {
      return new Promise((function(_this) {
        return function(resolve) {
          var user;
          _this.messages.push([userName, message]);
          user = new Hubot.User(userName, {
            room: _this.name
          });
          return _this.robot.receive(new Hubot.TextMessage(user, message), resolve);
        };
      })(this));
    };

    Room.prototype.destroy = function() {
      return this.robot.server.close();
    };

    Room.prototype.reply = function() {
      var envelope, i, len, results, str, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      results = [];
      for (i = 0, len = strings.length; i < len; i++) {
        str = strings[i];
        results.push(this.messages.push(['hubot', "@" + envelope.user.name + " " + str]));
      }
      return results;
    };

    Room.prototype.send = function() {
      var envelope, i, len, results, str, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      results = [];
      for (i = 0, len = strings.length; i < len; i++) {
        str = strings[i];
        results.push(this.messages.push(['hubot', str]));
      }
      return results;
    };

    Room.prototype.sendPrivate = function() {
      var envelope, i, len, results, str, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!(envelope.user.name in this.privateMessages)) {
        this.privateMessages[envelope.user.name] = [];
      }
      results = [];
      for (i = 0, len = strings.length; i < len; i++) {
        str = strings[i];
        results.push(this.privateMessages[envelope.user.name].push(['hubot', str]));
      }
      return results;
    };

    Room.prototype.robotEvent = function() {
      return this.robot.emit.apply(this.robot, arguments);
    };

    Room.prototype.enter = function(userName) {
      return new Promise((function(_this) {
        return function(resolve) {
          var user;
          user = new Hubot.User(userName, {
            room: _this.name
          });
          return _this.robot.receive(new Hubot.EnterMessage(user), resolve);
        };
      })(this));
    };

    Room.prototype.leave = function(userName) {
      return new Promise((function(_this) {
        return function(resolve) {
          var user;
          user = new Hubot.User(userName, {
            room: _this.name
          });
          return _this.robot.receive(new Hubot.LeaveMessage(user), resolve);
        };
      })(this));
    };

    return Room;

  })(Hubot.Adapter);

  Helper = (function() {
    Helper.Response = MockResponse;

    function Helper(scriptsPath) {
      this.scriptsPath = Path.resolve(Path.dirname(module.parent.filename), scriptsPath);
    }

    Helper.prototype.createRoom = function(options) {
      var file, i, len, ref, robot;
      if (options == null) {
        options = {};
      }
      robot = new MockRobot(options.httpd);
      if ('response' in options) {
        robot.Response = options.response;
      }
      if (Fs.statSync(this.scriptsPath).isDirectory()) {
        ref = Fs.readdirSync(this.scriptsPath).sort();
        for (i = 0, len = ref.length; i < len; i++) {
          file = ref[i];
          robot.loadFile(this.scriptsPath, file);
        }
      } else {
        robot.loadFile(Path.dirname(this.scriptsPath), Path.basename(this.scriptsPath));
      }
      robot.brain.emit('loaded');
      robot.adapter.name = options.name || 'room1';
      return robot.adapter;
    };

    return Helper;

  })();

  module.exports = Helper;

}).call(this);
